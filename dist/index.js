"use strict";function e(e){return e&&"object"==typeof e&&"default"in e?e.default:e}Object.defineProperty(exports,"__esModule",{value:!0});var t=require("react"),s=e(t),a=e(require("axios"));class i{constructor(e){this.baseUrl=e,this.get=(e,t,s,a)=>this.fetch(e,t,a),this.post=(e,t,s,a)=>this.fetchWithBody("POST",e,t,s,a),this.delete=(e,t,s,a)=>this.fetchWithBody("DELETE",e,t,s,a),this.put=(e,t,s,a)=>this.fetchWithBody("PUT",e,t,s,a),this.absUrl=e=>this.baseUrl+e,this.getHeaders=e=>e?{Authorization:e,"Access-Control-Allow-Origin":"*"}:{},this.handleCancel=()=>(console.log("Request canceled, @use-fetch-lib ðŸŽ‰"),null),this.fetch=(e,t,s={})=>a.get(this.absUrl(e),Object.assign(Object.assign({},s),{headers:Object.assign(Object.assign({},this.getHeaders(t)),"object"==typeof s.headers?s.headers:{})})).then(e=>e).catch(e=>{if(a.isCancel(e))return this.handleCancel();throw e}),this.fetchWithBody=(e,t,s,i={},c={})=>a(Object.assign(Object.assign({method:e,url:this.absUrl(t),data:i},c),{headers:Object.assign(Object.assign({},this.getHeaders(s)),"object"==typeof c.headers?c.headers:{})})).then(e=>e).catch(e=>{if(a.isCancel(e))return this.handleCancel();throw e})}}i.Cancelable=function(){let e;return t=>{const s=t;return function(){const t=[...arguments];if(t.length>4)throw new Error("Wrong Number of arguments, Check Api class");e&&e.cancel(),e=a.CancelToken.source();let i={cancelToken:e.token};return 4===t.length&&(i=Object.assign(Object.assign({},t[3]),i)),t[3]=i,s.apply(this,[...t])}}}();const c=t.createContext({authorizationToken:"",HttpService:new i(""),isProviderAdded:!1,cacheStore:{},updateCache:()=>{}}),n=e=>{try{return e.response&&e.response.data&&e.response.data.message||e.message}catch(t){return e}};exports.UseFetchProvider=e=>{const{children:a,baseUrl:n,authorizationToken:r}=e,o=new i(n),[d,l]=t.useState({});return s.createElement(c.Provider,{value:{authorizationToken:r,HttpService:o,isProviderAdded:!0,cacheStore:d,updateCache:(e,t)=>l(s=>Object.assign(Object.assign({},s),{[e]:t}))}},a)},exports.useFetch=e=>{const{url:s,method:r="get",mockData:o,shouldDispatch:d,cancelable:l=!1,cache:h=!1,shouldUseAuthToken:u=!0,dependencies:f,beforeServiceCall:g,options:b={}}="string"==typeof e?{url:e}:e,{authorizationToken:p,HttpService:j,isProviderAdded:C,cacheStore:O,updateCache:v}=t.useContext(c),k=l?i.Cancelable(j[r]):j[r];if(!C)throw new Error("You must wrap your higher level(parent) component with UseFetchProvider, before using useFetch ðŸ˜¬");let y=(e=>{let t="";return t="function"==typeof e?e():e,t})(p);const P=f||[],w=!!o,F=u?y:null,T="get"===r&&h;let m=a.CancelToken.source();const S={data:o,status:{isPending:!1,isRejected:!1,isFulfilled:!1,isCached:!1,isMocked:w,err:""}},[U,A]=t.useState(S),E=e=>{var t;if((e=>{if("function"==typeof e)return e();void 0!==e&&console.warn("useFetch arg `beforeServiceCall` must be a function")})(g),A({data:U.data?U.data:void 0,status:{isFulfilled:!1,isPending:!0,isRejected:!1,isCached:!1,isMocked:w,err:""}}),T){const e=O[s];if(e)return A(Object.assign(Object.assign({},e),{status:Object.assign(Object.assign({},e.status),{isMocked:!1,isFulfilled:!0,isCached:!0})}))}null===(t=k)||void 0===t||t(s,F,e,Object.assign(Object.assign({},b),{cancelToken:m.token})).then(({data:e})=>{const t={data:e,status:{isFulfilled:!0,isPending:!1,isRejected:!1,isMocked:!1,isCached:!1,err:""}};A(Object.assign({},t)),T&&v(s,t)}).catch(e=>{A({data:U.data,status:{isFulfilled:!1,isPending:!1,isCached:!1,isRejected:!0,isMocked:w,err:n(e)}})})};return t.useEffect(()=>{d?("function"==typeof d&&d()||"boolean"==typeof d&&d)&&E():void 0===d&&void 0!==f&&E()},[...P]),t.useEffect(()=>()=>{m.cancel()},[]),[U,E,e=>{if(U.data){const t=e(U.data);(e=>{T&&v(s,{data:e,status:Object.assign(Object.assign({},S.status),{isCached:!0,isMocked:!1,isFulfilled:!0})})})(t),A({data:t,status:{isFulfilled:!0,isPending:!1,isRejected:!1,isMocked:!1,isCached:!1,err:""}})}}]};
